<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GIF Dan√ßante ‚Äî Player Completo</title>
  <meta name="description" content="Player de GIFs sincronizados com √°udio ‚Äî temas, hist√≥rico, anima√ß√µes avan√ßadas, embeds e upload local." />
  <style>
    :root{
      --bg: #0b0b0d;
      --card: #111217;
      --text: #eaeaea;
      --muted: #9aa0a6;
      --accent: #7c4dff;
      --glass: rgba(255,255,255,0.04);
      --radius: 12px;
      --gap: 12px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;padding:0;font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;background:linear-gradient(180deg,var(--bg), #070707 90%);color:var(--text)}
    .app{max-width:1200px;margin:18px auto;padding:14px;background:linear-gradient(180deg,var(--card), #0b0b0b);border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.55)}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px}
    h1{margin:0;font-size:1.1rem}
    .subtitle{color:var(--muted);font-size:0.9rem}
    .topbar{display:flex;gap:12px;align-items:center}
    .themebar{display:flex;gap:8px;align-items:center}
    select,input,button{font-family:inherit}
    .controls{display:grid;grid-template-columns:1fr 360px;gap:14px;margin-top:12px}
    .card{background:var(--glass);padding:12px;border-radius:var(--radius);backdrop-filter: blur(6px)}
    .inputs{display:flex;flex-direction:column;gap:10px}
    input[type=text], select, input[type=file], input[type=number], .small-input{padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:var(--text);outline:none}
    .row{display:flex;gap:8px;align-items:center}
    button{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:600}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text)}
    .player{display:flex;gap:8px;align-items:center}
    .player audio{width:100%}
    .gif-area{margin-top:12px;display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:10px}
    .gif-card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:8px;border-radius:10px;display:flex;flex-direction:column;gap:6px;align-items:center;transition:transform .12s ease, box-shadow .12s ease;cursor:pointer}
    .gif-card:hover{transform:translateY(-6px);box-shadow:0 10px 30px rgba(0,0,0,0.45)}
    .gif-card img{width:100%;height:120px;object-fit:contain;border-radius:8px;transform-origin:center center}
    .settings{display:flex;flex-direction:column;gap:8px}
    label{font-size:0.85rem;color:var(--muted)}
    .small{font-size:0.85rem;color:var(--muted)}
    footer{margin-top:14px;display:flex;justify-content:space-between;align-items:center;gap:12px}
    .beat-animation{animation-name:beatMove;animation-iteration-count:infinite;animation-timing-function:ease-in-out}
    @keyframes beatMove{0%{transform:translateY(0) scale(1) rotate(0deg)}25%{transform:translateY(-8px) scale(1.02) rotate(2deg)}50%{transform:translateY(0) scale(1) rotate(0deg)}75%{transform:translateY(-6px) scale(1.01) rotate(-2deg)}100%{transform:translateY(0) scale(1) rotate(0deg)}}
    /* themes */
    body.theme-neon{--accent:#ff2d95;--bg:#07010a;--card:#0f0710}
    body.theme-vapor{--accent:#7a5cff;--bg:#0b0b1a;--card:#0f0e24}
    body.theme-min{--accent:#03a9f4;--bg:#ffffff;--card:#f4f6f8;--text:#111;--muted:#666}
    body.theme-dark{--accent:#8bc34a;--bg:#070707;--card:#0b0b0b}
    body.theme-rgb{--accent:#ff6b6b;--bg:#050406;--card:#0a0a0a}
    .theme-preview{display:flex;gap:8px}
    .theme-swatch{width:24px;height:24px;border-radius:6px;cursor:pointer;border:2px solid rgba(255,255,255,0.04)}
    .customizer{display:flex;flex-direction:column;gap:8px}
    .color-row{display:flex;gap:8px;align-items:center}
    .history{max-height:140px;overflow:auto;padding:8px;border-radius:8px;background:rgba(0,0,0,0.06)}
    /* drawing area */
    .draw-area{margin-top:12px;display:grid;grid-template-columns:1fr 320px;gap:12px}
    .canvas-wrap{background: #000; padding:10px; border-radius:10px; display:flex;justify-content:center;align-items:center}
    canvas{background:#111;border-radius:8px;max-width:100%}
    .tools{display:flex;flex-direction:column;gap:8px}
    .tool-row{display:flex;gap:8px;flex-wrap:wrap}
    .layer-list{max-height:180px;overflow:auto;padding:6px;background:rgba(0,0,0,0.04);border-radius:8px}
    .layer-item{padding:6px;border-radius:6px;background:rgba(255,255,255,0.02);margin-bottom:6px;cursor:pointer}
    .active{outline:2px solid rgba(255,255,255,0.06)}
    @media (max-width:980px){.controls{grid-template-columns:1fr}.draw-area{grid-template-columns:1fr}}
  </style>
</head>
<body class="theme-neon">
  <div class="app">
    <header>
      <div>
        <h1>GIF Dan√ßante ‚Äî Player Completo</h1>
        <div class="subtitle">Temas ‚Ä¢ GIFs ‚Ä¢ MP3 / YouTube / SoundCloud ‚Ä¢ Desenho avan√ßado</div>
      </div>
      <div class="topbar">
        <div class="themebar">
          <label class="small" style="margin-right:6px">Tema</label>
          <select id="themeSelect">
            <option value="theme-neon">Neon</option>
            <option value="theme-vapor">Vaporwave</option>
            <option value="theme-min">Minimal</option>
            <option value="theme-dark">Dark</option>
            <option value="theme-rgb">Gamer RGB</option>
          </select>
        </div>
        <div style="display:flex;gap:8px;align-items:center;margin-left:12px">
          <button id="addGifBtn" class="ghost">Adicionar GIF</button>
          <button id="resetBtn" class="ghost">Reset</button>
        </div>
      </div>
    </header>

    <div class="controls">
      <!-- left: audio + controls -->
      <div class="card">
        <div class="inputs">
          <label>Link da m√∫sica (MP3 direto)</label>
          <input id="mp3Input" type="text" placeholder="https://exemplo.com/minha-musica.mp3" />

          <label>Ou cole link do YouTube</label>
          <input id="ytInput" type="text" placeholder="https://www.youtube.com/watch?v=..." />

          <label>Ou cole link do SoundCloud</label>
          <input id="scInput" type="text" placeholder="https://soundcloud.com/usuario/faixa" />

          <label>Ou fa√ßa upload de um arquivo de √°udio (local)</label>
          <input id="fileInput" type="file" accept="audio/*" />

          <div class="row" style="margin-top:8px">
            <button id="playBtn">‚ñ∂Ô∏è Play</button>
            <button id="pauseBtn" class="ghost">‚è∏ Pause</button>
            <button id="stopBtn" class="ghost">‚èπ Stop</button>
          </div>

          <div class="player small" style="margin-top:8px">
            <label style="width:70px">Volume</label>
            <input id="volume" type="range" min="0" max="1" step="0.01" value="0.9" />
          </div>

          <div class="player small">
            <label style="width:70px">Gain</label>
            <input id="gain" type="range" min="0" max="3" step="0.01" value="1.0" />
          </div>

          <div class="row" style="align-items:center">
            <label style="margin-right:6px">Detec√ß√£o</label>
            <select id="modeSelect">
              <option value="auto">Auto (analisar)</option>
              <option value="manual">Manual BPM</option>
            </select>
            <input id="manualBpm" type="number" min="30" max="300" value="120" style="width:96px;margin-left:8px" />
          </div>

          <label>Sensibilidade do detector</label>
          <input id="sensitivity" type="range" min="0.5" max="3.0" step="0.01" value="1.3" />

          <label class="small">Observa√ß√£o: YouTube/SoundCloud podem ter limita√ß√µes de CORS ‚Äî MP3 direto ou upload local √© mais confi√°vel.</label>

          <div style="margin-top:8px">
            <label class="small">Hist√≥rico de faixas</label>
            <div id="trackHistory" class="history"></div>
          </div>
        </div>
      </div>

      <!-- right: GIFs and theme customizer -->
      <div class="card">
        <div class="settings">
          <label>GIFs adicionados (clique para remover)</label>
          <div id="gifArea" class="gif-area"></div>

          <div>
            <input id="newGifUrl" type="text" placeholder="Cole link direto do GIF (ex: https://...gif)" />
            <div class="row" style="margin-top:8px">
              <button id="addGifUrlBtn">Adicionar URL</button>
              <button id="addSampleBtn" class="ghost">Adicionar amostras</button>
            </div>
            <div class="note">Voc√™ pode arrastar + soltar GIFs diretamente na √°rea principal tamb√©m.</div>
          </div>

          <hr style="opacity:0.06;border:none;height:1px;margin:8px 0">

          <div class="customizer">
            <label class="small">Personalizar tema</label>
            <div class="color-row">
              <label class="small" style="width:90px">Cor de destaque</label>
              <input id="accentColor" type="color" value="#7c4dff" />
            </div>
            <div class="color-row">
              <label class="small" style="width:90px">Fundo</label>
              <input id="bgColor" type="color" value="#0b0b0b" />
            </div>
            <div class="row">
              <button id="applyThemeBtn" class="ghost">Aplicar Tema</button>
              <button id="resetThemeBtn" class="ghost">Reset Tema</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- player + drop area -->
    <div class="card" style="margin-top:12px">
      <div style="display:flex;gap:12px;align-items:center;justify-content:space-between">
        <div style="flex:1">
          <div class="player" style="gap:12px">
            <audio id="audioEl" crossorigin="anonymous"></audio>
            <div style="flex:1">
              <div class="small">BPM detectado: <span id="detectedBpm">‚Äî</span> | Beats/s: <span id="beatsPerSec">‚Äî</span></div>
            </div>
          </div>
        </div>

        <div style="width:320px;text-align:right">
          <div class="small">Feito para GitHub Pages ‚Ä¢ Salve como index.html</div>
        </div>
      </div>

      <div id="dropArea" style="margin-top:12px;padding:12px;border-radius:10px;border:2px dashed rgba(255,255,255,0.03);text-align:center">Arraste GIFs aqui ou clique em <strong>Adicionar GIF</strong></div>
    </div>

    <!-- drawing area -->
    <div class="draw-area">
      <div class="canvas-wrap card">
        <canvas id="drawCanvas" width="960" height="480"></canvas>
      </div>

      <div class="card tools">
        <div class="tool-row">
          <label>Ferramenta</label>
          <select id="toolSelect">
            <option value="brush">Pincel</option>
            <option value="eraser">Borracha</option>
            <option value="line">Linha</option>
            <option value="rect">Ret√¢ngulo</option>
            <option value="circle">C√≠rculo</option>
            <option value="spray">Spray</option>
            <option value="marker">Marcador</option>
            <option value="soft">Brush Suave</option>
            <option value="polygon">Pol√≠gono</option>
            <option value="move">Mover</option>
            <option value="zoom">Zoom</option>
          </select>
        </div>

        <div class="tool-row">
          <label>Cor</label>
          <input id="brushColor" type="color" value="#ffffff" />
          <label>Tamanho</label>
          <input id="brushSize" type="range" min="1" max="80" value="6" />
        </div>

        <div class="tool-row">
          <label>Opacidade</label>
          <input id="brushOpacity" type="range" min="0.05" max="1" step="0.01" value="1" />
          <label><input id="useGradient" type="checkbox" /> Gradiente</label>
        </div>

        <div class="tool-row">
          <button id="undoBtn" class="ghost">‚Ü©Ô∏è Desfazer</button>
          <button id="redoBtn" class="ghost">‚Ü™Ô∏è Refazer</button>
          <button id="clearCanvasBtn" class="ghost">üßΩ Limpar</button>
        </div>

        <div class="tool-row">
          <button id="saveCanvasBtn">üíæ Salvar PNG</button>
          <button id="importImageBtn" class="ghost">üìÅ Importar Imagem</button>
          <input type="file" id="importFile" accept="image/*" style="display:none" />
        </div>

        <hr style="opacity:0.06;border:none;height:1px;margin:8px 0" />

        <div>
          <label class="small">Camadas</label>
          <div id="layerList" class="layer-list"></div>
          <div class="tool-row" style="margin-top:8px">
            <button id="addLayerBtn" class="ghost">‚ûï Adicionar Camada</button>
            <button id="removeLayerBtn" class="ghost">üóë Remover Camada</button>
          </div>
        </div>

        <div class="tool-row" style="margin-top:8px">
          <button id="toggleGridBtn" class="ghost">Toggle Grade</button>
          <button id="toggleRulerBtn" class="ghost">Toggle R√©gua</button>
          <button id="zoomInBtn" class="ghost">Zoom +</button>
          <button id="zoomOutBtn" class="ghost">Zoom -</button>
        </div>
      </div>
    </div>

    <footer>
      <div class="small">Dica: para detec√ß√£o mais confi√°vel use MP3 direto ou upload local.</div>
      <div class="small">Vers√£o unificada ‚Äî GIFs, m√∫sicas e desenho avan√ßado</div>
    </footer>
  </div>

  <!-- hidden slots for embeds -->
  <div id="ytPlayerRoot" style="display:none"></div>
  <div id="scPlayerRoot" style="display:none"></div>

  <script>
    /* -------------------------
       STATE + DOM REFERENCES
    ------------------------- */
    const state = {
      audioCtx: null, analyser: null, sourceNode: null, gainNode: null, raf: null,
      lastBeatTime: 0, bpm: null, gifs: [], sensitivity: 1.3, volume: 0.9, fileObjectUrl: null,
      ytPlayer: null, scIframe: null, beatTimestamps: [], trackHistory: []
    };

    // DOM
    const mp3Input = document.getElementById('mp3Input');
    const ytInput = document.getElementById('ytInput');
    const scInput = document.getElementById('scInput');
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const stopBtn = document.getElementById('stopBtn');
    const audioEl = document.getElementById('audioEl');
    const gifArea = document.getElementById('gifArea');
    const addGifBtn = document.getElementById('addGifBtn');
    const addGifUrlBtn = document.getElementById('addGifUrlBtn');
    const newGifUrl = document.getElementById('newGifUrl');
    const addSampleBtn = document.getElementById('addSampleBtn');
    const detectedBpm = document.getElementById('detectedBpm');
    const beatsPerSec = document.getElementById('beatsPerSec');
    const modeSelect = document.getElementById('modeSelect');
    const manualBpm = document.getElementById('manualBpm');
    const sensitivityEl = document.getElementById('sensitivity');
    const volumeEl = document.getElementById('volume');
    const gainEl = document.getElementById('gain');
    const themeSelect = document.getElementById('themeSelect');
    const resetBtn = document.getElementById('resetBtn');
    const fileInput = document.getElementById('fileInput');
    const trackHistoryEl = document.getElementById('trackHistory');
    const dropArea = document.getElementById('dropArea');
    const accentColor = document.getElementById('accentColor');
    const bgColor = document.getElementById('bgColor');
    const applyThemeBtn = document.getElementById('applyThemeBtn');
    const resetThemeBtn = document.getElementById('resetThemeBtn');

    /* -------------------------
       AUDIO: setup + analysis
    ------------------------- */
    function initAudioContext(){
      if (state.audioCtx) return;
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      state.audioCtx = new AudioContext();
      state.analyser = state.audioCtx.createAnalyser();
      state.analyser.fftSize = 2048;
      state.gainNode = state.audioCtx.createGain();
      state.gainNode.gain.value = state.volume;
      state.analyser.smoothingTimeConstant = 0.85;
    }

    function connectAudioElement(){
      if (!state.audioCtx) initAudioContext();
      if (state.sourceNode) try{ state.sourceNode.disconnect(); }catch(e){}
      try{
        state.sourceNode = state.audioCtx.createMediaElementSource(audioEl);
      }catch(e){
        console.warn('createMediaElementSource failed', e);
      }
      if (state.sourceNode){
        state.sourceNode.connect(state.gainNode);
        state.gainNode.connect(state.analyser);
        state.analyser.connect(state.audioCtx.destination);
      } else {
        console.warn('No sourceNode ‚Äî analysis may not work (CORS).');
      }
    }

    // Improved beat detection
    const energyHistory = [];
    function analyzeBeat(){
      if (!state.analyser) return;
      const data = new Uint8Array(state.analyser.frequencyBinCount);
      state.analyser.getByteFrequencyData(data);
      let sum = 0;
      for (let i=0;i<data.length;i++) sum += data[i]*data[i];
      const instantEnergy = sum / data.length;
      energyHistory.push(instantEnergy);
      if (energyHistory.length > 120) energyHistory.shift();

      const avg = energyHistory.reduce((a,b)=>a+b,0)/energyHistory.length;
      const variance = energyHistory.reduce((a,b)=>a+(b-avg)*(b-avg),0)/energyHistory.length;
      const threshold = (parseFloat(sensitivityEl.value) || 1.3) * (avg + Math.sqrt(variance));

      if (instantEnergy > threshold && Date.now() - state.lastBeatTime > 120){
        state.lastBeatTime = Date.now();
        registerBeat(state.lastBeatTime);
        onBeatDetected();
      }

      if (state.beatTimestamps.length >= 2){
        const diffs = [];
        for (let i=1;i<state.beatTimestamps.length;i++) diffs.push(state.beatTimestamps[i]-state.beatTimestamps[i-1]);
        const avgMs = diffs.reduce((a,b)=>a+b,0)/diffs.length;
        const bpm = Math.round(60000/avgMs);
        state.bpm = bpm;
        detectedBpm.textContent = bpm;
        beatsPerSec.textContent = (bpm/60).toFixed(2);
      }

      const rms = Math.sqrt(instantEnergy);
      applyVisuals(rms);
      state.raf = requestAnimationFrame(analyzeBeat);
    }

    function registerBeat(ts){ state.beatTimestamps.push(ts); if (state.beatTimestamps.length>16) state.beatTimestamps.shift(); }

    function applyVisuals(rms){
      const mode = modeSelect.value; let baseMs = 500;
      if (mode === 'manual'){ const bpm = Number(manualBpm.value) || 120; baseMs = 60000/bpm; }
      else if (state.bpm) baseMs = 60000/state.bpm;
      const gain = Number(gainEl.value) || 1.0;
      const normalized = Math.min(2, Math.max(0.05, (rms/24) * gain));
      const durationMs = Math.max(60, baseMs / normalized);
      const imgs = document.querySelectorAll('.gif-card img');
      imgs.forEach((img,i)=>{
        img.classList.add('beat-animation');
        const offset = 1 + (i%4)*0.04;
        img.style.animationDuration = (durationMs/1000 * offset).toFixed(3)+'s';
      });
    }

    function onBeatDetected(){
      const imgs = document.querySelectorAll('.gif-card img');
      imgs.forEach(img=>{ img.style.transform='translateY(-8px) scale(1.04)'; setTimeout(()=>{ img.style.transform=''; },160); });
    }

    /* -------------------------
       CONTROLS: play/pause/stop
    ------------------------- */
    playBtn.addEventListener('click', async ()=>{
      if (!state.audioCtx) initAudioContext();
      if (state.audioCtx && state.audioCtx.state === 'suspended') await state.audioCtx.resume();
      stopAll(false);
      const mp3 = mp3Input.value.trim(); const yt = ytInput.value.trim(); const sc = scInput.value.trim();
      if (state.fileObjectUrl){ audioEl.crossOrigin='anonymous'; audioEl.loop=false; audioEl.volume = Number(volumeEl.value)||0.9; connectAudioElement(); audioEl.play().catch(e=>console.warn('play failed',e)); state.raf = requestAnimationFrame(analyzeBeat); return; }
      if (mp3){ audioEl.src = mp3; audioEl.crossOrigin='anonymous'; audioEl.loop=false; audioEl.volume = Number(volumeEl.value)||0.9; connectAudioElement(); audioEl.play().catch(e=>console.warn('play failed',e)); state.raf = requestAnimationFrame(analyzeBeat); addToHistory(mp3); return; }
      if (sc){ embedSoundCloud(sc); console.info('SoundCloud embedded ‚Äî an√°lise limitada por CORS.'); addToHistory(sc); return; }
      if (yt){ embedYouTube(yt); console.info('YouTube embedded ‚Äî an√°lise limitada por CORS.'); addToHistory(yt); return; }
      alert('Cole um link MP3 direto, SoundCloud, YouTube ou fa√ßa upload de um arquivo de √°udio.');
    });

    pauseBtn.addEventListener('click', ()=>{ if (audioEl && !audioEl.paused) audioEl.pause(); if (state.ytPlayer) try{ state.ytPlayer.pauseVideo(); }catch(e){} if (state.scIframe) try{ postMessageToSC('pause'); }catch(e){} });
    stopBtn.addEventListener('click', ()=>{ stopAll(true); });

    function stopAll(clearFile=true){
      if (audioEl){ audioEl.pause(); audioEl.currentTime = 0; if (clearFile){ audioEl.src=''; state.fileObjectUrl=null; } }
      if (state.ytPlayer){ try{ state.ytPlayer.stopVideo(); }catch(e){} }
      if (state.scIframe){ try{ postMessageToSC('pause'); }catch(e){} }
      if (state.raf) cancelAnimationFrame(state.raf);
      energyHistory.length = 0;
      state.beatTimestamps = [];
      detectedBpm.textContent = '‚Äî';
      beatsPerSec.textContent = '‚Äî';
    }

    volumeEl.addEventListener('input', ()=>{ audioEl.volume = Number(volumeEl.value); state.volume = Number(volumeEl.value); if (state.gainNode) state.gainNode.gain.value = state.volume; });
    gainEl.addEventListener('input', ()=>{ if (state.gainNode) state.gainNode.gain.value = Number(gainEl.value); });
    sensitivityEl.addEventListener('input', ()=>{ state.sensitivity = Number(sensitivityEl.value); });

    modeSelect.addEventListener('change', ()=>{ if (modeSelect.value === 'manual') detectedBpm.textContent = manualBpm.value; else detectedBpm.textContent = '‚Äî'; });
    manualBpm.addEventListener('input', ()=>{ if (modeSelect.value === 'manual') detectedBpm.textContent = manualBpm.value; });

    /* -------------------------
       GIF MANAGEMENT
    ------------------------- */
    function renderGifs(){
      gifArea.innerHTML = '';
      state.gifs.forEach((url,idx)=>{
        const card = document.createElement('div');
        card.className = 'gif-card';
        const img = document.createElement('img');
        img.src = url;
        img.alt = 'GIF ' + (idx+1);
        img.loading = 'lazy';
        img.addEventListener('error', ()=>{ img.style.opacity = 0.5; img.alt = 'Erro ao carregar'; });
        card.addEventListener('click', ()=>{ state.gifs.splice(idx,1); renderGifs(); });
        card.appendChild(img);
        const label = document.createElement('div'); label.className='small'; label.textContent='Clique para remover';
        card.appendChild(label);
        gifArea.appendChild(card);
      });
    }

    addGifUrlBtn.addEventListener('click', ()=>{ const url = newGifUrl.value.trim(); if (!url) return alert('Cole o link do GIF'); state.gifs.push(url); newGifUrl.value=''; renderGifs(); });
    addGifBtn.addEventListener('click', ()=>{ const url = prompt('Cole o link do GIF (direto .gif)'); if (url) { state.gifs.push(url.trim()); renderGifs(); } });
    addSampleBtn.addEventListener('click', ()=>{ const samples = ['https://i.imgur.com/4AiXzf8.gif','https://media.giphy.com/media/3o7aD2saalBwwftBIY/giphy.gif','https://media.giphy.com/media/l0MYt5jPR6QX5pnqM/giphy.gif']; state.gifs.push(...samples); renderGifs(); });

    resetBtn.addEventListener('click', ()=>{ if (confirm('Resetar a aplica√ß√£o?')){ state.gifs=[]; renderGifs(); stopAll(); mp3Input.value=''; ytInput.value=''; scInput.value=''; trackHistoryEl.innerHTML=''; state.trackHistory=[]; } });

    themeSelect.addEventListener('change', ()=>{ document.body.className = themeSelect.value; });

    // Drag & drop GIFs
    ['dragenter','dragover'].forEach(e=>{ dropArea.addEventListener(e, (ev)=>{ ev.preventDefault(); dropArea.style.borderColor = 'rgba(255,255,255,0.15)'; }); });
    ['dragleave','drop'].forEach(e=>{ dropArea.addEventListener(e, (ev)=>{ ev.preventDefault(); dropArea.style.borderColor = 'rgba(255,255,255,0.03)'; }); });

    dropArea.addEventListener('drop', (ev)=>{ const files = Array.from(ev.dataTransfer.files || []); files.forEach(f=>{ if (f.type.startsWith('image/')){ const url = URL.createObjectURL(f); state.gifs.push(url); renderGifs(); } }); });

    // File input for audio
    fileInput.addEventListener('change', (ev)=>{ const file = ev.target.files[0]; if (!file) return; if (state.fileObjectUrl) URL.revokeObjectURL(state.fileObjectUrl); state.fileObjectUrl = URL.createObjectURL(file); audioEl.src = state.fileObjectUrl; audioEl.crossOrigin = 'anonymous'; audioEl.style.display='block'; audioEl.play().catch(e=>console.warn('play failed',e)); if (!state.audioCtx) initAudioContext(); connectAudioElement(); state.raf = requestAnimationFrame(analyzeBeat); addToHistory(file.name || 'upload'); });

    /* -------------------------
       EMBEDS: YouTube / SoundCloud
    ------------------------- */
    let ytApiLoaded = false;
    function loadYouTubeApi(callback){ if (ytApiLoaded){ callback(); return; } const tag = document.createElement('script'); tag.src = 'https://www.youtube.com/iframe_api'; document.body.appendChild(tag); window.onYouTubeIframeAPIReady = ()=>{ ytApiLoaded = true; callback(); }; }

    function extractYouTubeID(url){ try{ const u = new URL(url); if (u.hostname.includes('youtube.com')) return u.searchParams.get('v'); if (u.hostname.includes('youtu.be')) return u.pathname.slice(1); }catch(e){ return null; } return null; }

    function embedYouTube(link){
      const videoId = extractYouTubeID(link);
      if (!videoId) return alert('Link YouTube inv√°lido');
      loadYouTubeApi(()=>{
        const root = document.getElementById('ytPlayerRoot');
        root.innerHTML = '';
        const div = document.createElement('div'); div.id = 'yt-player'; root.appendChild(div);
        state.ytPlayer = new YT.Player('yt-player',{
          height:'200', width:'320', videoId: videoId,
          playerVars: { autoplay:1, controls:1, modestbranding:1 },
          events: { onReady: (e)=>{ try{ e.target.playVideo(); }catch(e){} }, onStateChange: (e)=>{} }
        });
        root.style.display = 'block';
      });
    }

    function embedSoundCloud(link){
      const root = document.getElementById('scPlayerRoot');
      root.innerHTML = '';
      const iframe = document.createElement('iframe');
      iframe.width='100%'; iframe.height='120'; iframe.scrolling='no'; iframe.frameBorder='no'; iframe.allow='autoplay';
      iframe.src = 'https://w.soundcloud.com/player/?url=' + encodeURIComponent(link) + '&auto_play=true&hide_related=false&show_comments=true&show_user=true&show_reposts=false&visual=false';
      root.appendChild(iframe); root.style.display='block'; state.scIframe = iframe;
    }
    function postMessageToSC(cmd){ if (!state.scIframe) return; const msg = { method: cmd }; state.scIframe.contentWindow.postMessage(msg, '*'); }

    /* -------------------------
       HISTORY
    ------------------------- */
    function addToHistory(entry){ state.trackHistory.unshift({time: new Date().toLocaleString(), entry}); if (state.trackHistory.length>20) state.trackHistory.pop(); renderHistory(); }
    function renderHistory(){ trackHistoryEl.innerHTML = ''; state.trackHistory.forEach(t=>{ const d = document.createElement('div'); d.className='small'; d.style.padding='6px 4px'; d.textContent = `${t.time} ‚Äî ${t.entry}`; trackHistoryEl.appendChild(d); }); }

    /* -------------------------
       THEME CUSTOMIZER
    ------------------------- */
    applyThemeBtn.addEventListener('click', ()=>{ document.documentElement.style.setProperty('--accent', accentColor.value); document.documentElement.style.setProperty('--bg', bgColor.value); document.documentElement.style.setProperty('--card', shadeColor(bgColor.value, -8)); });
    resetThemeBtn.addEventListener('click', ()=>{ document.documentElement.style.removeProperty('--accent'); document.documentElement.style.removeProperty('--bg'); document.documentElement.style.removeProperty('--card'); accentColor.value = '#7c4dff'; bgColor.value = '#0b0b0b'; });
    function shadeColor(hex,percent){ const f = parseInt(hex.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent; const R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF; const r=Math.round((t-R)*p/100)+R,g=Math.round((t-G)*p/100)+G,b=Math.round((t-B)*p/100)+B; return `#${(0x1000000 + (r<<16) + (g<<8) + b).toString(16).slice(1)}`; }

    /* -------------------------
       INIT / UTIL
    ------------------------- */
    document.addEventListener('DOMContentLoaded', ()=>{
      state.gifs = ['https://i.imgur.com/4AiXzf8.gif'];
      renderGifs();
      document.body.className = 'theme-neon';
      renderHistory();
    });

    ['click','touchstart'].forEach(evt=>{ window.addEventListener(evt, async ()=>{ if (state.audioCtx && state.audioCtx.state === 'suspended') try{ await state.audioCtx.resume(); }catch(e){} },{once:false}); });

    window.addEventListener('beforeunload', ()=>{ if (state.raf) cancelAnimationFrame(state.raf); if (state.sourceNode) try{ state.sourceNode.disconnect(); }catch(e){} });

    /* ============================
       DRAWING: advanced system
       (layers, undo/redo, tools)
       ============================ */
    const canvas = document.getElementById('drawCanvas');
    const ctx = canvas.getContext('2d');

    // layers: array of offscreen canvases
    let layers = [];
    let activeLayer = 0;
    let history = [];
    let redoStack = [];
    let isDrawing = false;
    let currentTool = 'brush';
    let startX = 0, startY = 0;
    let zoom = 1;
    let showGrid = false, showRuler = false;

    const toolSelect = document.getElementById('toolSelect');
    const brushColor = document.getElementById('brushColor');
    const brushSize = document.getElementById('brushSize');
    const brushOpacity = document.getElementById('brushOpacity');
    const useGradient = document.getElementById('useGradient');
    const layerList = document.getElementById('layerList');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const clearCanvasBtn = document.getElementById('clearCanvasBtn');
    const saveCanvasBtn = document.getElementById('saveCanvasBtn');
    const importImageBtn = document.getElementById('importImageBtn');
    const importFile = document.getElementById('importFile');
    const addLayerBtn = document.getElementById('addLayerBtn');
    const removeLayerBtn = document.getElementById('removeLayerBtn');
    const toggleGridBtn = document.getElementById('toggleGridBtn');
    const toggleRulerBtn = document.getElementById('toggleRulerBtn');
    const zoomInBtn = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');

    function createLayer(){
      const off = document.createElement('canvas');
      off.width = canvas.width; off.height = canvas.height;
      layers.push(off);
      activeLayer = layers.length - 1;
      renderLayerList();
      saveHistory();
      render();
    }

    function removeActiveLayer(){
      if (layers.length <= 1) return alert('Deixe pelo menos uma camada.');
      layers.splice(activeLayer,1);
      activeLayer = Math.max(0, activeLayer-1);
      renderLayerList();
      saveHistory();
      render();
    }

    function renderLayerList(){
      layerList.innerHTML = '';
      layers.forEach((l,i)=>{
        const div = document.createElement('div'); div.className = 'layer-item'; div.textContent = `Camada ${i+1}`; if (i===activeLayer) div.classList.add('active');
        div.onclick = ()=>{ activeLayer = i; renderLayerList(); };
        layerList.appendChild(div);
      });
    }

    function saveHistory(){
      // snapshot all layers
      const snap = layers.map(l=>{
        const c = document.createElement('canvas');
        c.width = canvas.width; c.height = canvas.height;
        c.getContext('2d').drawImage(l,0,0);
        return c;
      });
      history.push(snap);
      if (history.length>50) history.shift();
      redoStack = [];
    }

    function undo(){
      if (history.length===0) return;
      redoStack.push(layers);
      layers = history.pop().map(c=>{
        const off = document.createElement('canvas'); off.width = canvas.width; off.height = canvas.height; off.getContext('2d').drawImage(c,0,0); return off;
      });
      activeLayer = Math.min(activeLayer, layers.length-1);
      renderLayerList(); render();
    }

    function redo(){
      if (redoStack.length===0) return;
      history.push(layers);
      layers = redoStack.pop().map(c=>{
        const off = document.createElement('canvas'); off.width = canvas.width; off.height = canvas.height; off.getContext('2d').drawImage(c,0,0); return off;
      });
      renderLayerList(); render();
    }

    // initialize one layer
    createLayer();

    function getActiveCtx(){ return layers[activeLayer].getContext('2d'); }

    function clearActive(){
      const c = getActiveCtx(); c.clearRect(0,0,canvas.width,canvas.height); saveHistory(); render();
    }

    function applyToolStroke(x,y,prevX,prevY){
      const c = getActiveCtx();
      c.lineCap = 'round';
      c.lineJoin = 'round';
      c.globalAlpha = parseFloat(brushOpacity.value);
      c.lineWidth = parseFloat(brushSize.value);
      if (useGradient.checked){
        const grad = c.createRadialGradient(prevX,prevY,1,x,y,200);
        grad.addColorStop(0, brushColor.value); grad.addColorStop(1, 'transparent');
        c.strokeStyle = grad; c.fillStyle = grad;
      } else {
        c.strokeStyle = brushColor.value; c.fillStyle = brushColor.value;
      }
      c.beginPath(); c.moveTo(prevX,prevY); c.lineTo(x,y); c.stroke();
    }

    function render(){
      // reset transform
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.save();
      ctx.scale(zoom,zoom);
      layers.forEach(l=> ctx.drawImage(l,0,0));
      if (showGrid) drawGrid();
      if (showRuler) drawRuler();
      ctx.restore();
    }

    function drawGrid(){
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.lineWidth = 0.5;
      const step = 20;
      for (let x=0; x<canvas.width; x+=step){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
      for (let y=0; y<canvas.height; y+=step){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }
      ctx.restore();
    }

    function drawRuler(){
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillRect(0,0,canvas.width,20); ctx.fillRect(0,0,20,canvas.height);
      ctx.fillStyle = '#fff'; ctx.font = '10px sans-serif';
      for (let x=0;x<canvas.width;x+=50){ ctx.fillText(x, x, 12); }
      for (let y=0;y<canvas.height;y+=50){ ctx.fillText(y, 2, y+8); }
      ctx.restore();
    }

    // mouse handling: support different tools
    let prevX = 0, prevY = 0;
    canvas.addEventListener('mousedown', (e)=>{
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) / zoom;
      const y = (e.clientY - rect.top) / zoom;
      isDrawing = true; prevX = x; prevY = y;
      currentTool = toolSelect.value;
      if (currentTool === 'line' || currentTool === 'rect' || currentTool === 'circle' || currentTool === 'polygon'){
        saveHistory();
      } else {
        saveHistory();
      }
    });

    canvas.addEventListener('mousemove', (e)=>{
      if (!isDrawing) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) / zoom;
      const y = (e.clientY - rect.top) / zoom;
      const c = getActiveCtx();
      if (currentTool === 'brush' || currentTool === 'soft' || currentTool === 'marker'){
        applyToolStroke(x,y,prevX,prevY);
      } else if (currentTool === 'eraser'){
        c.clearRect(x - brushSize.value/2, y - brushSize.value/2, brushSize.value, brushSize.value);
      } else if (currentTool === 'spray'){
        for (let i=0;i<20;i++){ const a=Math.random()*Math.PI*2; const r=Math.random()*brushSize.value; c.fillStyle = brushColor.value; c.fillRect(x+Math.cos(a)*r, y+Math.sin(a)*r, 1,1); }
      }
      prevX = x; prevY = y;
      render();
    });

    canvas.addEventListener('mouseup', (e)=>{
      if (!isDrawing) return;
      isDrawing = false;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) / zoom;
      const y = (e.clientY - rect.top) / zoom;
      const c = getActiveCtx();
      if (currentTool === 'line'){ c.beginPath(); c.moveTo(prevX,prevY); c.lineTo(x,y); c.strokeStyle = brushColor.value; c.lineWidth = brushSize.value; c.stroke(); }
      if (currentTool === 'rect'){ c.strokeStyle = brushColor.value; c.lineWidth = brushSize.value; c.strokeRect(prevX,prevY, x-prevX, y-prevY); }
      if (currentTool === 'circle'){ const r = Math.hypot(x-prevX, y-prevY); c.beginPath(); c.arc(prevX,prevY, r, 0, Math.PI*2); c.strokeStyle = brushColor.value; c.lineWidth = brushSize.value; c.stroke(); }
      render();
    });

    // touch support (basic)
    canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); const t = e.touches[0]; const rect = canvas.getBoundingClientRect(); const x=(t.clientX-rect.left)/zoom; const y=(t.clientY-rect.top)/zoom; isDrawing=true; prevX=x; prevY=y; saveHistory(); });
    canvas.addEventListener('touchmove', (e)=>{ e.preventDefault(); const t=e.touches[0]; const rect=canvas.getBoundingClientRect(); const x=(t.clientX-rect.left)/zoom; const y=(t.clientY-rect.top)/zoom; if (!isDrawing) return; applyToolStroke(x,y,prevX,prevY); prevX=x; prevY=y; render(); });
    canvas.addEventListener('touchend', (e)=>{ isDrawing=false; });

    // undo / redo / clear / save / import
    undoBtn.addEventListener('click', undo);
    redoBtn.addEventListener('click', redo);
    clearCanvasBtn.addEventListener('click', ()=>{ if (confirm('Limpar camada ativa?')){ getActiveCtx().clearRect(0,0,canvas.width,canvas.height); saveHistory(); render(); }});
    saveCanvasBtn.addEventListener('click', ()=>{ const link=document.createElement('a'); link.download='desenho.png'; link.href=canvas.toDataURL(); link.click(); });
    importImageBtn.addEventListener('click', ()=> importFile.click());
    importFile.addEventListener('change', (e)=>{ const f = e.target.files[0]; if (!f) return; const img = new Image(); img.onload = ()=>{ getActiveCtx().drawImage(img,0,0,canvas.width,canvas.height); saveHistory(); render(); }; img.src = URL.createObjectURL(f); });

    addLayerBtn.addEventListener('click', ()=> createLayer());
    removeLayerBtn.addEventListener('click', ()=> removeActiveLayer());
    toggleGridBtn.addEventListener('click', ()=>{ showGrid = !showGrid; render(); });
    toggleRulerBtn.addEventListener('click', ()=>{ showRuler = !showRuler; render(); });
    zoomInBtn.addEventListener('click', ()=>{ zoom = Math.min(3, zoom+0.1); render(); });
    zoomOutBtn.addEventListener('click', ()=>{ zoom = Math.max(0.2, zoom-0.1); render(); });

    // keyboard shortcuts
    window.addEventListener('keydown', (e)=>{
      if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); }
      if (e.ctrlKey && e.key === 'y') { e.preventDefault(); redo(); }
      if (e.key === '[') { zoom = Math.max(0.2, zoom-0.1); render(); }
      if (e.key === ']') { zoom = Math.min(3, zoom+0.1); render(); }
    });

    // ensure UI reflects state changes
    function uiTick(){ brushSize.dispatchEvent(new Event('input')); renderLayerList(); requestAnimationFrame(uiTick); }
    uiTick();

    // small safety: initial render
    render();

  </script>
</body>
</html>
